---
title: 'AI Agents'
description: 'LangGraph-powered intelligent agents for document processing'
icon: 'robot'
---

# AI Agents System

The 3WM system uses LangGraph to orchestrate multiple specialized AI agents that work together to process invoices intelligently.

## Agent Architecture

<Card title="LangGraph Workflow Engine" icon="diagram-project">
  3WM uses LangGraph's stateful graph architecture to coordinate multiple agents:
  - **State Management**: Shared state across all agents
  - **Conditional Routing**: Dynamic workflow based on document type and confidence
  - **Tool Integration**: MCP-powered tools for external data access
  - **Error Handling**: Graceful fallbacks and retry mechanisms
</Card>

## Core Agents

### 1. Extraction Agent

The extraction agent handles initial document processing:

```python
# From app/agents/extraction_agent.py
class ExtractionAgent:
    """Extracts structured data from documents"""
    
    def __init__(self):
        self.llm = ChatOpenAI(model="gpt-4-turbo", temperature=0)
        self.tools = [
            pdf_extract_tool,
            ocr_fallback_tool,
            text_parser_tool
        ]
    
    async def extract(self, document: Document) -> ExtractedData:
        # Try PDF text extraction first
        text = await self.pdf_extract_tool(document)
        
        # Fall back to OCR if needed
        if not text or len(text) < 100:
            text = await self.ocr_fallback_tool(document)
        
        # Parse structured fields
        return await self.parse_invoice_fields(text)
```

<CardGroup cols={2}>
  <Card title="Capabilities" icon="tools">
    - PDF text extraction
    - OCR fallback for scans
    - Multi-language support
    - Field confidence scoring
  </Card>
  
  <Card title="Output" icon="file-export">
    - Vendor information
    - Invoice number & date
    - Line items with amounts
    - Tax calculations
  </Card>
</CardGroup>

### 2. Validation Agent

Ensures data quality and consistency:

```python
# From app/agents/validation_agent.py
class ValidationAgent:
    """Validates extracted data against business rules"""
    
    async def validate(self, state: AgentState) -> ValidationResult:
        extracted_data = state["extracted_data"]
        
        # Run validation checks
        checks = {
            "vendor_exists": await self.check_vendor(extracted_data.vendor),
            "vat_valid": await self.validate_vat(extracted_data.vat_number),
            "totals_match": self.verify_calculations(extracted_data),
            "duplicate_check": await self.check_duplicates(extracted_data)
        }
        
        # Calculate confidence score
        confidence = sum(1 for check in checks.values() if check) / len(checks)
        
        return ValidationResult(
            is_valid=all(checks.values()),
            confidence=confidence,
            issues=[k for k, v in checks.items() if not v]
        )
```

### 3. Matching Agent

Performs 3-way matching between invoices, POs, and receipts:

```python
# From app/agents/matching_agent.py
class MatchingAgent:
    """Handles 3-way matching logic"""
    
    async def match(self, state: AgentState) -> MatchResult:
        invoice = state["extracted_data"]
        
        # Find related documents
        po = await self.find_purchase_order(invoice.po_number)
        receipt = await self.find_goods_receipt(invoice.vendor, invoice.items)
        
        # Perform matching
        matches = {
            "po_match": self.match_with_po(invoice, po),
            "receipt_match": self.match_with_receipt(invoice, receipt),
            "quantity_match": self.verify_quantities(invoice, po, receipt),
            "price_match": self.verify_prices(invoice, po)
        }
        
        return MatchResult(
            matched=all(matches.values()),
            confidence=self.calculate_match_confidence(matches),
            discrepancies=self.identify_discrepancies(matches)
        )
```

### 4. Decision Agent

Makes routing decisions based on validation and matching results:

```python
# From app/agents/decision_agent.py
class DecisionAgent:
    """Routes documents based on confidence and business rules"""
    
    def route(self, state: AgentState) -> str:
        confidence = state["confidence_score"]
        amount = state["extracted_data"].total_amount
        
        # Routing logic
        if confidence >= 0.95 and amount < 10000:
            return "auto_approve"
        elif confidence >= 0.80:
            return "human_review"
        elif confidence >= 0.60:
            return "enhanced_validation"
        else:
            return "manual_entry"
```

## LangGraph Workflow

The complete workflow is defined as a stateful graph:

```python
# From app/agents/graph.py
from langgraph.graph import StateGraph, END

# Define the workflow
workflow = StateGraph(AgentState)

# Add nodes (agents)
workflow.add_node("extract", extraction_agent)
workflow.add_node("validate", validation_agent)
workflow.add_node("match", matching_agent)
workflow.add_node("decide", decision_agent)
workflow.add_node("auto_approve", auto_approval_agent)
workflow.add_node("human_review", human_review_agent)

# Define edges
workflow.set_entry_point("extract")
workflow.add_edge("extract", "validate")
workflow.add_edge("validate", "match")
workflow.add_edge("match", "decide")

# Conditional routing from decision agent
workflow.add_conditional_edges(
    "decide",
    lambda x: x["next_action"],
    {
        "auto_approve": "auto_approve",
        "human_review": "human_review",
        "enhanced_validation": "validate",
        "manual_entry": END
    }
)

# Compile the graph
app = workflow.compile()
```

## MCP Tool Integration

The agents use Model Context Protocol (MCP) for external tool access:

<Tabs>
  <Tab title="Web Search">
    ```python
    @tool
    def search_supplier_info(query: str) -> dict:
        """Search for supplier information online"""
        return mcp_client.execute(
            "web_search",
            {"query": f"{query} company VAT chamber commerce"}
        )
    ```
  </Tab>
  
  <Tab title="Database Operations">
    ```python
    @tool
    def lookup_vendor_history(vendor_id: str) -> list:
        """Get historical invoices from vendor"""
        return mcp_client.execute(
            "database_query",
            {
                "table": "invoices",
                "filter": {"vendor_id": vendor_id},
                "limit": 10
            }
        )
    ```
  </Tab>
  
  <Tab title="External APIs">
    ```python
    @tool
    def validate_vat_number(vat: str, country: str) -> bool:
        """Validate VAT via VIES API"""
        return mcp_client.execute(
            "vat_validation",
            {"vat_number": vat, "country_code": country}
        )
    ```
  </Tab>
</Tabs>

## Natural Language Interface

The system includes a conversational agent for queries:

```python
# Natural language query processing
async def process_query(query: str) -> str:
    # Parse intent
    intent = await parse_query_intent(query)
    
    # Route to appropriate tools
    if intent.type == "count":
        result = await count_documents(intent.filters)
    elif intent.type == "search":
        result = await search_invoices(intent.criteria)
    elif intent.type == "analyze":
        result = await analyze_vendor_patterns(intent.vendor)
    
    # Format response
    return format_natural_response(result)
```

### Example Queries

<CodeGroup>
```python "Count Query"
# User: "How many invoices from ACME Corp this month?"
result = await agent.query(
    "How many invoices from ACME Corp this month?"
)
# Returns: "Found 23 invoices from ACME Corp in January 2024, 
#          totaling €45,678.90"
```

```python "Analysis Query"
# User: "Show me the payment pattern for Tech Supplies"
result = await agent.query(
    "Show me the payment pattern for Tech Supplies"
)
# Returns: "Tech Supplies typically invoices on the 15th of each month,
#          with an average amount of €3,456. Payment terms are Net 30."
```

```python "Search Query"
# User: "Find all pending invoices over 5000 euros"
result = await agent.query(
    "Find all pending invoices over 5000 euros"
)
# Returns: List of matching invoices with details
```
</CodeGroup>

## Performance Optimization

### Caching Strategy

```python
from functools import lru_cache
from redis import Redis

redis_client = Redis()

@lru_cache(maxsize=1000)
def get_vendor_info(vendor_id: str) -> dict:
    """Cache vendor information for repeated lookups"""
    # Check Redis first
    cached = redis_client.get(f"vendor:{vendor_id}")
    if cached:
        return json.loads(cached)
    
    # Fetch from database
    vendor = db.get_vendor(vendor_id)
    
    # Cache for future use
    redis_client.setex(
        f"vendor:{vendor_id}",
        3600,  # 1 hour TTL
        json.dumps(vendor)
    )
    
    return vendor
```

### Parallel Processing

```python
async def process_batch(documents: List[Document]) -> List[Result]:
    """Process multiple documents in parallel"""
    
    # Create tasks for parallel execution
    tasks = [
        process_document(doc) 
        for doc in documents
    ]
    
    # Execute in parallel with concurrency limit
    results = await asyncio.gather(
        *tasks,
        return_exceptions=True
    )
    
    return results
```

## Monitoring & Observability

### Langfuse Integration

All agent interactions are tracked in Langfuse:

```python
from langfuse import Langfuse

langfuse = Langfuse()

@langfuse.trace
async def process_invoice(document: Document):
    """Process invoice with full observability"""
    
    # Each step is automatically traced
    extraction = await extraction_agent.extract(document)
    validation = await validation_agent.validate(extraction)
    matching = await matching_agent.match(extraction)
    
    # Log metrics
    langfuse.score(
        name="extraction_confidence",
        value=extraction.confidence
    )
    
    return result
```

### Key Metrics

<CardGroup cols={3}>
  <Card title="Extraction Accuracy" icon="bullseye">
    Track field-level accuracy rates
  </Card>
  
  <Card title="Processing Time" icon="clock">
    Monitor agent execution times
  </Card>
  
  <Card title="Confidence Distribution" icon="chart-bar">
    Analyze confidence score patterns
  </Card>
</CardGroup>

## Best Practices

<Steps>
  <Step title="Design for Failure">
    Always include fallback mechanisms and retry logic
  </Step>
  
  <Step title="Monitor Everything">
    Use Langfuse to track all LLM calls and agent decisions
  </Step>
  
  <Step title="Cache Intelligently">
    Cache vendor data and validation results to reduce API calls
  </Step>
  
  <Step title="Test Thoroughly">
    Use the evaluation framework to test agent performance
  </Step>
</Steps>

## Next Steps

- [API Reference](/3wm-project/api-reference/agent) - Agent API endpoints
- [Architecture](/3wm-project/architecture/components) - Technical details
- [Deployment](/3wm-project/deployment/overview) - Production setup

---

*Built with ❤️ by [Sky Dust](https://skydust.io)* 